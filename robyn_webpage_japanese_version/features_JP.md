*本資料はRobyn公式ページの[機能説明](https://facebookexperimental.github.io/Robyn/docs/features)の日本語版です。
# Robynの基本機能
Robynの実行方法と技術要素に関する詳細な説明です。

---
## モデルのインプット

`robyn_inputs()`関数ではデータセットにおけるすべてのモデル設定情報を指定します。ここでは、基本的な概念をいくつか説明します。


```
InputCollect <- robyn_inputs(
  dt_input = dt_simulated_weekly
  ,dt_holidays = dt_prophet_holidays
  ,date_var = "DATE" # 日付のフォーマットは"2020-01-01"
  ,dep_var = "revenue" # 一つの変数のみ
  ,dep_var_type = "revenue" # "revenue" もしくは "conversion"
  ,prophet_vars = c("trend", "season", "holiday") # "trend","season", "weekday" & "holiday"
  ,prophet_country = "DE"# 一つの国を指定
  ,context_vars = c("competitor_sales_B", "events") # 例: 競合、割引、失業率など
  ,paid_media_spends = c("tv_S","ooh_S","print_S","facebook_S", "search_S") # メディア出稿金額
  ,paid_media_vars = c("tv_S", "ooh_S","print_S","facebook_I","search_clicks_P") # メディア露出指標、存在しない場合はpaid_media_spendsと同じものを利用する
  ,organic_vars = c("newsletter") # コストのかかっていないマーケティング活動
  ,factor_vars = c("events") # context_varsとorganic_varsの中でファクター型の変数を指定
  ,window_start = "2016-01-01"
  ,window_end = "2018-12-31"
  ,adstock = "geometric" # geometric、weibull_cdf、もくしはweibull_pdf
)
```

### ペイドメディア変数

ペイドメディアの変数を選択するためのベストプラクティスの詳細については、アナリストガイドの[データ収集](https://github.com/yu-ya-tanaka/Robyn-Community-Japan-Resource/blob/main/robyn_webpage_japanese_version/analysts-guide-to-MMM_JP.md#データ収集)セクションを参照してください。

ペイドメディア変数については、ユーザーが `paid_media_vars` と `paid_media_spends` の両方を指定する必要があります。`paid_media_vars`はメディアの露出指標を指し、例えばテレビのGRP、検索のクリック数、フェイスブックのインプレッション数などです。`paid_media_spends`はメディア支出金額を指します。2つの要素数は同じで、メディアの順番も同じでなければなりません。露出指標がない場合は、`paid_media_spends`と同じものを使用します。

**注**: 現在のRobynはメディア支出のみを用いてメインモデルを構築します。予算配分に不確実性をもたらすため、モデルのインプットとして露出を使うことは非推奨です。Robynでは支出と露出の変換にミカエリス・メンテン関数を使用します。この関数は非線形の柔軟性がありますが、費用と露出の関係はしばしば単変量変換には複雑すぎるケースがあります。以前のバージョンでは、この支出-露出の変換の不正確さが、信頼できない予算配分の原因となっていました。露出指標を使用することの重要性は理解していますが、予算配分の信頼性を重視し、メディア支出でモデリングを行うことにしました。実用的な解決策が見つかり次第、露出指標によるモデリングを再導入します。

上記の理由で非推奨ではありますが、Robynで露出指標を利用する価値は依然大きいです。もし支出と露出の間の関連性が弱いと検出された場合、それは露出指標が支出とは異なるパターンを持っていることを示しています。この場合、Robynはより良いモデリング結果を得るためにチャネルを分割することを推奨します。メタを例にとると、リターゲティングとプロスペクティングのキャンペーンはCPMや効率が大きく異なる可能性があります。その場合、リターゲティングとプロスペクティングでメタを分割することが有意義な結果をもら足すことになります。

一般的に、先に進む前に、有料メディアのデータが完全で正確であることを確認することが重要です。有料メディアの変数変換については、変数変換のセクションで詳しく説明します。

### オーガニック変数

Robynでは、ユーザーが`organic_vars`を指定することで、直接コストをかけずに実施したマーケティング活動をモデル化することができます。通常、これにはニュースレター、プッシュ通知、ソーシャルメディア投稿などが含まれます。さらに、オーガニック変数は、ペイドメディア変数のようにキャリーオーバー効果（アドストック効果）やサチュレーション（飽和効果）を持つことが期待されます。それぞれの変換テクニックは、オーガニック変数にも適用されます。これらの変換の詳細は、次のセクションで説明します。


#### よくあるオーガニック変数の例
- ブログ記事のリーチやインプレッション
- オーガニック＆ソーシャルメディアにおけるインプレッション
- SEOの改善
- メールマガジン
- UGCのリーチ数


### コンテキスト変数

コンテキスト変数はすべて `context_vars` の要素として指定する必要があります。モデルに含めるべきコンテクスト変数の詳細については、アナリストガイドの[データ収集](https://github.com/yu-ya-tanaka/Robyn-Community-Japan-Resource/blob/main/robyn_webpage_japanese_version/analysts-guide-to-MMM_JP.md#データ収集)のセクションを参照してください。

### デマンド（需要）マップ

デマンドマップを作成することでビジネス指標に影響を与えるすべての要素を特定するのに役立ちます。特にMMMを初めて実行するときには、この図を作成することを強くお勧めします。また、定期的に見直すことも有効です。

![organic media](https://facebookexperimental.github.io/Robyn/img/organic-media.png)
---

## 変数変換

MMM is typlically characterised by the following two hypothesis:
MMMは、典型的には以下の2つの仮説によって特徴づけられます:
1. 広告投資は遅延効果を持つ/時間を超えて効果は持ち越される。例えば、今日広告を見たことで、来週購買を行うなど。
2. 広告投資には逓減効果がある。例えば、あるチャンネルにコストと投下すればするほど、得られる限界リターンは少なくなる。

ロビンは、これらの仮説を説明するために、2種類の変換を行います:
1. アドストック変換
2. サチュレーション（飽和）変換


### アドストック（広告残存効果）

アドストックとは、広告の遅延効果仮説のことで、広告の効果が最初の露出の後から遅れつつ、減衰する可能性があるという理論を反映したものです。それはまた、広告想起やキャンペーン認知度のような特定のブランドエクイティ指標にも関連しています。具体例は、"私は製品を購入するX日前に広告を見た"です。通常、この「記憶」は時間が経つにつれて減衰していくと考えられています。しかし、この「記憶」の効果がまず増大してから減少すると考えるのが正当なケースもあります。例えば、車やクレジットなどの高額商品は、特にオフラインチャンネルの場合、広告の後に直接購入される可能性は低いです。そのため、このような商品のオフラインチャネルでは、ピークが遅くなるラグ効果を想定するのが普通です。同時に、デジタルチャネルからのオンラインコンバージョンは、ピークに遅れがなく、減衰のみを扱うのが適しているかもしれません。

アドストックの公式は次のように一般化できます:

`media_adstocked_i = media_raw_i + decay_rate *  media_raw_i-1`　ここで`i`は与えられた期間

Robynで選択できるアドストック変換の選択肢は3つです:

#### Geometric
1パラメータのGeometric関数では、固定減衰率パラメータとしてthetaが設定されています。例えば、theta = 0.75 の場合の広告効果は、期間1の広告の75%が期間2に引き継がれることを意味します。RobynによるGeometric変換の実装は[こちら](https://github.com/facebookexperimental/Robyn/blob/main/R/R/transformation.R#L57)で確認できます。概念的には以下のように示されます:

`media_adstocked_ij = media_raw_ij + decay_rate_j * media_raw_i-1_j` ここで、`i` は特定の時間期間を表し、`j` はメディア変数を示します。`decay_rate_j` は各メディア変数ごとの定数であり、幾何学的パラメータ `theta` と等しい値です。

週次レベルのモデルを構築してきたこれまでの経験から得られた目安として、TVは0.3〜0.8の範囲で広告効果が持続する傾向があり、屋外広告/印刷広告/ラジオクオ國は0.1〜0.4、デジタルは0.0〜0.3の範囲となっています。これはあくまで経験則によるアドバイスですので、ご自身のモデルを構築する際には最適な判断を行ってください。

![Example Geometric Adstocks](https://facebookexperimental.github.io/Robyn/img/adstockintro.png)

Geometricのもう一つの便利な特性は、無限級数の極限が `1 / (1 - theta)` に等しいという点です。例えば、`theta = 0.75` の場合、その無限級数は `1 / (1 - 0.75) = 4` になります。Robynは支出に対して広告効果の変換を行うため、広告効果の変換が生のデータにどの程度の「インフレ」を加えるかを直感的に把握することができます。一方で、Geometricは、時間と共に変動するより柔軟な減衰や遅延効果を捉えることができません。これらは、以下のワイブル広告効果によって解決されます。

#### Weibull PDF & CDF

Robynは、2パラメータのワイブル関数をPDFおよびCDFの形式で提供しています。シータが固定減衰率に等しい1パラメータのGeometric関数と比較して、Weibull関数は、shapeとscal のパラメータによってより柔軟な変換が可能で、時間と共に変動する減衰率を表現できます。RobynによるWeibull変換の実装は[こちら](https://github.com/facebookexperimental/Robyn/blob/main/R/R/transformation.R#L128)で確認できます。また、Weibullは概念的に以下のように示されます：

`media_adstocked_ij = media_raw_ij + decay_rate_ij * media_raw_i-1_j` ここで、`i` は特定の時間期間を表し、`j` はメディア変数を示します。Geometric関数の固定減衰率と比較して、`decay_rate_ij` はメディア変数 `j` の時間期間 `i` に特有の値です。

以下のグラフは、Weibull広告効果が `shape` と `scale` の2つのパラメータに対して持つ柔軟性を示しています。この柔軟性は、追加のハイパーパラメータのために、より多くの計算リソースが必要になるというコストを伴います。**ワイブルPDFは、コンバージョンウィンドウが長い商品に対して強く推奨されます。** 一部のケースでは、ワイブルPDFを使用することで大幅に良好なフィットが得られることが確認されています。

![Example Weibull Adstocks](https://facebookexperimental.github.io/Robyn/img/weibulladstocks.png)

**Weibull CDFF広告効果:** Weibull CDFの累積分布関数は、固定減衰率を持つGeometricアドストックと比較して、柔軟な減衰率の表現を可能にする `shape` と `scale` の2つのパラメータを持ちます。`shape` パラメータは減衰曲線の曲率を制御します。推奨される範囲は `c(0.0001, 2)` です。`shape` が大きいほど曲線はS字型になり、小さいほどL字型になります。`scale` は曲線の変曲点を制御します。`scale` は広告効果の半減期を大幅に延長するため、非常に保守的な範囲 `c(0, 0.1)` を推奨します。

**Weibull PDF広告効果:** Weibull PDFの確率密度関数も `shape` と `scale` の2つのパラメータを持ち、CDFと同様に柔軟な減衰率を提供します。違いは、ワイブルPDFが遅延効果を提供することです。`shape > 2` の場合、曲線はx = 0の後にピークを迎え、x = 0でNULLスロープを持ち、広告効果の遅延効果とより鋭い上昇および減少を可能にします。`scale` パラメータはピークの相対的な位置をx軸上で制限します。`1 < shape < 2` の場合、曲線はx = 0の後にピークを迎え、x = 0で無限の正のスロープを持ち、遅延効果と広告効果の遅い増減を可能にします。`shape = 1` の場合、曲線はx = 0でピークを迎え、指数減衰に変わり、`scale` は変曲点を制御します。`0 < shape < 1` の場合、曲線はx = 0でピークを迎え、減衰が増加します。`scale` は変曲点を制御します。すべての形状が重要な場合、`shape` の推奨範囲は `c(0.0001, 10)` です。強力な遅延効果のみが関心の対象である場合、`shape` の範囲として `c(2.0001, 10)` を推奨します。すべての場合において、`scale` の保守的な範囲として `c(0, 0.1)` を推奨します。Weibull PDFの大きな柔軟性により、Nevergradによるハイパーパラメータ探索の自由度が増し、収束にはより多くの反復が必要となります。

### サチュレーション（飽和）

収穫逓減の法則（飽和とも呼ばれる）は、広告投資の追加単位ごとに反応が減少する速度が増加することを示しています。この仮説は、マーケティングミックスモデルの変数変換として実装されます。

![Diminishing returns1](https://facebookexperimental.github.io/Robyn/img/diminishingreturns1.png)

従属変数に対するメディア変数の非線形な反応は、さまざまな方法でモデル化できます。一般的なアプローチには、メディア変数の対数変換、べき変換、またはシグモイド型の関数が含まれます。これらの変換の共通点は、すべて連続的かつ微分可能であることです。これは、非線形最適化アルゴリズムを使用した予算配分において重要です。

Robynは、柔軟な変換のためにヒル関数を使用し、S字型またはL字型の飽和を実装しています。Robynでのヒル関数の実装は[こちら](https://github.com/facebookexperimental/Robyn/blob/main/R/R/transformation.R#L210)で確認でき、概念的には以下のように示されています:

`media_saturated_j = 1 / (1 + (gamma_j / media_adstocked_j) ^ alpha_j)` ここで、`j` はメディア変数を示します。

上記の `gamma_j` は、変数の変曲点にスケーリングされています。`alpha` と `gamma` の値を変えることで、飽和曲線の曲率や変曲点に変化が生じることが以下の図で確認できます:

![Diminishing returns1](https://facebookexperimental.github.io/Robyn/img/diminishingreturns3.png)

このプロットでは、x軸が支出、y軸が反応を示しています。`alpha` はC字型とS字型の曲線の形を制御します。`alpha` の推奨範囲は `c(0.5, 3)` です。`alpha` が大きいほどS字型に、小さいほどC字型になります。`gamma` は曲線の変曲点を制御します。`gamma` の推奨範囲は `c(0.3, 1)` です。`gamma` が大きいほど、反応曲線の変曲点が遅くなります。

飽和に関連するもう一つの重要な概念は限界反応です。数学的には、限界反応は非線形曲線上の特定の点での一次導関数に等しいです。より分かりやすく言えば、限界反応とは、特定の支出レベルにおける「次の1ドルの反応」を指します。例えば、平均的な週の支出が1000ドルの場合、「1001ドル目の支出から得られるリターンは何か？」ということです。これは、非線形な予算配分がどのように機能するかを理解するための基礎です。限界反応の詳細については、**[こちらの記事](https://medium.com/@gufengzhou/the-convergence-of-marginal-roas-in-the-budget-allocation-in-robyn-5d407aebf021): "The convergence of marginal ROAS in the budget allocation in Robyn"** をご覧ください。


---

## Prophetによる目的変数のトレンドと季節性への分解

現実世界の時系列データの問題において、データ内のトレンドや季節性を理解することが、より良い当てはまりのために重要です。従来のMMMでは、これは通常、線形トレンドやダミー変数による季節性などのシンプルな仮定を使って手動で行われていました。モデル構築プロセスにおける人為的なバイアスを減らすために、RobynはMetaが開発した時系列予測パッケージであるProphetを使用して、トレンド、季節、祝日、曜日の分解を行います。多くの場合、これによりモデルの当てはまりが大幅に向上することが確認されています。時系列分解の仕組みの詳細は[Prophetのドキュメント](https://facebook.github.io/prophet/docs/trend_changepoints.html)で確認できます。

### 時系列分解の例
以下のプロットでは、Robynの週次[サンプルデータ](https://github.com/facebookexperimental/Robyn/tree/main/R/data)からの従属変数「収益」がトレンド、季節、祝日成分に分解されています。曜日は日次データにのみ使用可能なため、ここには含まれていません。「イベント」変数は外部回帰変数として含まれています。これにより、Robynはカテゴリカル変数を連続変数に「変換」し、後の計算が簡素化されます。

![prophet 2](https://facebookexperimental.github.io/Robyn/img/prophet_decomp.png)

---

## リッジ回帰

マーケティングミックスモデルは、多くの場合、多重共線性の問題に直面します。これは、異なるメディアチャネルを同時に運用することが一般的であるためです（例えば、クリスマスにすべてのチャネルで支出を増やすなど）。言い換えれば、回帰モデルにおいて複数の独立変数が相関している場合、多重共線性が発生します。これにより、係数推定が不安定になり、係数の有意性の解釈が困難になり、過適合が生じます。

正則化回帰は、上記の多重共線性の課題に対処するための一般的な選択肢です。Robynは、L2正則化、別名リッジ回帰を使用しています。Lasso（L1正則化）回帰ではなくリッジを選択したのは、Lassoは特徴量を削除する傾向がある一方で、リッジはその大きさを減らす傾向があるからです。MMMでは、多くのメディア変数がゼロ効果を持つことは非現実的です。

Robynは、正則化回帰のフィッティングを行うために `glmnet` パッケージを使用しています。その実装は[こちら](https://github.com/facebookexperimental/Robyn/blob/main/R/R/model.R#L1047)で確認できます。リッジ回帰の損失関数は以下の通りです。

![Ridge Regression Formula](https://facebookexperimental.github.io/Robyn/img/Ridge.png)

加法モデルの式は以下の通りです:

![Ridge Regression Formula](https://facebookexperimental.github.io/Robyn/img/model_specification.png)

「なぜベイズモデルを使用しないのか」という質問をよく寄せられます。ベイズフレームワークは、ビジネスへの実装においてその魅力的な特性の多さから人気が高まっています。特に、ベイズ事前分布をネイティブのモデルキャリブレーション機能として使用できる点や、ベイズの信用区間の直感的な解釈が挙げられます。

ここで指摘したいのは、リッジ回帰は正規分布/ガウス分布を使用したベイズ回帰と等価であり、Lassoはベイズのラプラス分布事前分布に対応しているという点です。これは学術的に十分に研究されており、T.Hastieらによる ["An Introduction to Statistical Learning"](https://hastie.su.domains/ISLR2/ISLRv2_corrected_June_2023.pdf) のページ249の段落 **"Bayesian Interpretation of Ridge Regression and the Lasso"** で詳しく説明されています。

Robynは最適化アプローチとして多目的アルゴリズムを使用しています。これは、MMMが解決しようとする問題が複数の目標を持つと信じているからです。MMMは「科学」であると同時に「技術」であると言われることがよくあります。モデルは良い予測を行うだけでなく、「理にかなっている」ことも期待されます。この観点から、これを多目的最適化問題として考えるのは非常に自然なことです。正則化回帰は、当社の最適化手法（Nevergradの進化的アルゴリズムであるTwoPointsDE）に適しています。これは、通常のベイズ回帰のMCMCプロセスとは異なり、進化的な反復により（ハイパー）パラメータが推定されるためです。多目的最適化とNevergradについての詳細は以下をご覧ください。

---
<a name="nevergrad-moo"></a>
## Nevergradによる多目的ハイパーパラメータ最適化

すべてのMMM実践者が知っている「妥当性確認」の方法の一つとして、複数のモデル候補がある場合、多少のフィットが低くても、現在の支出配分とより良く一致するモデルを好むことが一般的です。例えば、メディア支出が90%/10%に分かれているデータセットで、貢献度が10%/90%となるモデルは、どれだけフィットが良くても妥当性が低いと考えられます。一方で、貢献度が70%/30%のモデルはより妥当性があると見なされます。

言い換えると、良いMMMは予測精度と解釈可能性の両方を備えている必要があります。これは科学と技術の対立としてよく引き合いに出されます。Robynチームではこれを多目的最適化問題と捉えています。なぜなら、現実世界では単に予測するだけでは不十分だからです。私たちは、この「妥当性確認」を最適化に組み込むことが重要であり、追加の目的関数としてパラメータ化することによって実現しています。**多目的ハイパーパラメータ最適化の実装は、Robynにおける最も重要なイノベーションと見なされています。** 同時に、ハイパーパラメータの使用により、広告効果の減衰、飽和、正則化ペナルティ、さらには時系列の検証におけるトレーニングサイズの自動選択を強化します。

Robynは、Metaの勾配フリー最適化プラットフォームである[**Nevergrad**](https://facebookresearch.github.io/nevergrad/)を使用して、この最適化タスクを実行します。Nevergradの「ask & tell」インターフェースを通じて、Robynはハイパーパラメータの値を探索し、そのスコア（目的関数）に基づいて最適な値を導き出します。

<a name="objective-function"></a>
### 目的関数

現在、Robynは3つの目的関数をハイパーパラメータ最適化の「目標」として実装しています。
- **NRMSE**: 正規化平均二乗誤差で、**予測誤差**とも呼ばれます。Robynでは、データセットをトレーニング/検証/テストに分割して時系列検証を行うことが可能です。時系列検証を行わない場合、トレーニングエラー `nrmse_train` が進化反復の目的関数となります。時系列検証を行う場合、検証エラー `nrmse_val` が目的関数となり、`nrmse_test` はサンプル外の予測性能を評価するために使用されます。
- **DECOMP.RSSD**: 分解二乗距離の平方根は、**ビジネス誤差**とも呼ばれ、Robynの重要な発明の一つです。これは、有料メディア変数の支出シェアと効果シェアの差を表します。この指標は、メディアROASの収束に関して議論の余地があることを認識していますが、現実世界では常に複数の目的が協力し合い、最適化プロセスでトレードオフが発生します。DECOMP.RSSDは極端な分解を排除し、モデル選択を絞り込むのに役立ちます。
- **MAPE.LIFT**: キャリブレーション時に有効になるリフトテストの平均絶対パーセンテージ誤差で、**キャリブレーション誤差**として参照されます。Robynのもう一つの重要な発明であり、予測効果と因果効果の差を最小化することが可能です。

### ハイパーパラメータ

Robynには現在4つのハイパーパラメータがあります。
- **Adstocking**: Geometric広告効果を選択する場合の `theta`、またはWeibull広告効果を選択する場合の `shape` および `scale`
- **Saturation**: ヒル関数における `alpha` および `gamma`
- **Regularization**: リッジ回帰のペナルティ項に対する `lambda`
- **Validation**: トレーニングデータの割合を示す `train_size`

有料メディアおよびオーガニックメディア変数が増えると、ハイパーパラメータの数も増加します。例えば、10個のメディア変数を幾何学的広告効果で使用する場合、ハイパーパラメータの総数は32です: 10個のtheta + 10個のalpha + 10個のgamma + 1個のlambda + 1個のトレーニングサイズ。Weibull広告効果を使用する場合、総数は42になります: 10個のshape + 10個のscale + 10個のalpha + 10個のgamma + lambda + 1個のトレーニングサイズ。ハイパーパラメータを追加することでRobynは最適な解を見つける柔軟性が向上しますが、収束に時間がかかるため、モデルの実行時間が長くなるというトレードオフが発生します。

[**パレート最適**](https://en.wikipedia.org/wiki/Pareto_efficiency)の概念を使用して、Robynは常に最適なモデル候補のセットを出力します。下の図は、パレートモデルソリューションの例です。チャート内の各点は探索されたモデルソリューションを表し、左下の線がパレートフロント1〜3であり、すべての反復から得られた最良のモデル結果が含まれています。2つの軸（x軸がNRMSE、y軸がDECOMP.RSSD）は、最小化されるべき2つの目的関数です。反復が増えるにつれて、座標の左下方向に向かう傾向が明確に見られます。これは、Nevergradがモデル結果を最適な方向に導いている証拠です。

![pareto chart](https://facebookexperimental.github.io/Robyn/img/pareto_front.png)

**進化的アルゴリズム**の前提は自然選択の概念に基づいています。進化的アルゴリズムでは、モデルが探索する係数の組み合わせがいくつかの反復で生き残り繁殖し、不適合なモデルは消滅して後の世代に寄与しないという考えです。

Robynでは、最適な収束を得るために**2000回以上の反復**を推奨しています。これにより、各反復が次の世代にフィードバックを提供し、alpha、gamma、thetaの最適な係数値にモデルが向かうように導きます。また、少なくとも5回のトライアルを推奨しています。トライアルは、独立したモデルの初期化セットであり、それぞれに指定した反復数が含まれます。例えば、`set_iter`オブジェクトで2000回の反復を設定し、5回のトライアルを実行すると、合計10000回の異なる反復とモデルソリューションが得られることになります。

Robynでは、以下の条件を満たした場合、モデルが**収束した**と見なします。

基準1: 最後の四分位範囲の標準偏差が最初の3つの四分位範囲の標準偏差の平均より小さいこと。

基準2: 最後の四分位範囲の絶対中央値が最初の四分位範囲の絶対中央値 - 最初の3つの四分位範囲の標準偏差の平均 * 2 よりも小さいこと。

これらの四分位範囲はモデルの反復数によって順序付けられています。たとえば、1000回の反復を行った場合、最初の200回の反復が最初の四分位範囲を構成します。これらの基準は、NRMSEとDECOMP.RSSDの標準偏差と平均が開始時点より改善されていることを示し、変動性が低下していることを確認する試みです。

また、以下のコードを実行することで、多目的最適化の収束をリッジラインの可視化で確認することもできます。

`OutputModels$convergence$moo_distrb_plot`

![moo cloud plot](https://facebookexperimental.github.io/Robyn/img/moo_cloud_plot.png)

---
## 時系列評価

`robyn_run()` で `ts_validation = TRUE` を設定すると、NRMSE検証のために3分割の時系列が有効になります。この際、トレーニングデータの割合を決定するハイパーパラメータ `train_size` もRobynに含まれます。例えば、`train_size = 0.7` の場合、`val_size` と `test_size` はそれぞれ0.15になります。このハイパーパラメータはカスタマイズ可能で、デフォルトの範囲は `c(0.5, 0.8)` です。設定可能な範囲は `c(0.1, 1)` の間です。

![time series validation](https://facebookexperimental.github.io/Robyn/img/time_series_validation_and_convergence.png)

![time series validation](https://facebookexperimental.github.io/Robyn/img/actual_vs_predicted_response_ts.png)

---
## モデルのクラスタリング

下記のセッションモデルの[Onepager](#model-onepager)のプロット4で示されているように、k-meansクラスタリングはモデルの選択肢をさらに絞り込むために使用されます。RobynはROASまたはCPAの不確実性を計算するためにブートストラップを使用します。
- すべてのパレート最適モデル候補に対してk-meansクラスタリングを使用し、類似のハイパーパラメータを持つモデルのクラスターを見つけます。定数kはクラスタ数を示します。
- `k = "auto"`（デフォルト値）の場合、WSS（群内平方和）が計算され、1から20の範囲で最適なk値が自動的に見つかります。前のk値からのWSS変化が5%未満のk値が選択されます。これは下のスクリーンショットで視覚化されています。
- 各kクラスター内では、正規化された3つの目的関数（NRMSE、DECOMP.RSSD、およびキャリブレーションが使用された場合はMAPE）に基づいて最良のモデルが選択されます。
- [MOO](#nevergrad-moo) の文脈では、各クラスターは異なる局所最適におけるサブポピュレーションと見なされます。

![Pareto clusters WSS](https://facebookexperimental.github.io/Robyn/img/pareto_clusters_wss.png)

---
## 実験（リフトテスト）によるキャリブレーション

ランダム化比較試験（RCT）は、科学における因果関係を推定するための確立された手法です。広告効果測定においても、RCTの結果を「真実」として適用することで、マーケティングミックスモデルに因果関係を導入できます。Robynは、MMMキャリブレーションを多目的最適化の目的関数として実装し、因果結果と予測されたメディアの貢献の違いをパラメータ化します。

![Calibration chart](https://facebookexperimental.github.io/Robyn/img/calibration1.png)

上記のチャートはキャリブレーションの概念を示しています。キャリブレーションエラー **MAPE.LIFT** は、予測誤差やビジネス誤差と並ぶ第3の目的関数として実装されており、図中の式に示されているように、予測されたメディア貢献と「真実」との違いを表しています。

### キャリブレーションの主な効果

- Analytic Edgeのホワイトペーパー ["The Value of Calibrating MMM with Lift Experiments"](https://analytic-edge.com/blog/the-value-of-calibrating-mmm-with-lift-experiments/) によると、**キャリブレーションされていないモデルは、真実と平均25%の差を示す** ことが分かっています。
- Robyn 2022ハッカソンの優勝者による[シミュレーション実験](https://medium.com/@gufengzhou/calibrated-mmm-better-predicts-true-roas-d5adfc8abdc4)でも、以下の結果が示されています:
  - **キャリブレーションされたモデルは優れている**: すべてのキャリブレーション済みモデルは、キャリブレーションされていないモデルに比べて、予測されたROASが真のROASに近づき、MAPEも小さくなります。
  - **一つをキャリブレーションすれば、すべてに良い効果がある**: シミュレーションされた2つのチャンネル（TVとFB）のうち1つだけをキャリブレーションした場合でも、他のチャンネルもキャリブレーションされていない場合に比べて真のROASに近い予測を行います。
  - **より多くのチャンネルをキャリブレーションするほど、精度が向上する**: 両方のシミュレーションチャンネル（TVとFB）をキャリブレーションすると、真のROASに対するエラーが最も低くなります。Robynのキャリブレーションは、キャリブレーションエラー（MAPE.LIFT）を多目的最適化の目的関数として設計されており、真のROASを回復するためです。
  - **より多くのスタディがあるほど、精度が向上する**: チャンネルごとに最大10のスタディを使用することで、真のROAS予測が大幅に改善されます。

### 実験の種類

WARCの記事 ["A step-by-step guide to calibrating marketing mix models with experiments"](https://www.warc.com/content/paywall/article/a-step-by-step-guide-to-calibrating-marketing-mix-models-with-experiments/en-GB/152212) で指摘されているように、広告測定には主に2種類の実験があります。

- **販売実験（セールスリフト）**: これらの実験は、マーケティング活動が販売に与える影響（オンラインコンバージョンなど）を測定することを目的としています。例としては、[MetaのConversion Lift](https://www.facebook.com/business/m/one-sheeters/conversion-lift)や[GoogleのConversion Lift](https://support.google.com/google-ads/answer/12003020?hl=en)などがあります。これらの実験は、テストグループとコントロールグループのコンバージョン率を比較することで、マーケティングの因果効果を推定します。
  - **メリット**: 販売への直接的な影響を把握でき、比較的計画および実行が簡単です。
  - **デメリット**: コンバージョンに関連する結果のみを測定でき、非コンバージョン効果を見落とす可能性があります。デジタルチャネルに限定されます。
- **地域実験（エリアテスト）**: 地域別実験は、DMAs、州、都市など特定の地理的地域でのマーケティング活動の影響を分析します。マーケティング介入を受けた地域とコントロール地域の結果を比較することで、反応の空間的変動を定量化します。
  - **メリット**: 空間的変動や地域特有の反応を捉え、地域に特化したマーケティングに役立ちます。オフラインでも実行可能であり、クロスチャネルでのテストが可能です。デジタルを含むチャネルのグループ全体を評価することも可能です。アドレス可能なTVやOOHなど、オフラインチャネルにも適用できる可能性があります。
  - **デメリット**: 地域間でのスピルオーバー効果に影響される可能性があり、比較性を確保するための慎重な設計が必要です。

Robynでは、キャリブレーションの入力としてデータフレームを `robyn_inputs()` 関数で受け入れます。関数の使用方法は[デモ](https://github.com/facebookexperimental/Robyn/blob/main/demo/demo.R#L262)で確認できます。

---
<a name="model-onepager"></a>
## モデルOnepager

Robynは、結果の解釈やカスタム分析を支援するために、指定されたパスにさまざまなグラフィカルおよび表形式の出力を自動でエクスポートします。パレート最適モデルごとにOnepagerがエクスポートされ、`robyn_outputs()` 関数を実行後に得られます。以下はその一例です。

![ModelResults1 chart](https://facebookexperimental.github.io/Robyn/img/modelresults2.png)

1. **レスポンスのウォーターフォール型分解図:** このチャートは、すべての独立変数の絶対および割合の貢献を示しています。パーセンテージは合計で100%になり、「変数Aがx%の収益を説明できる」と解釈できます。**「ベースライン」の概念**は、全体の分解に関連する場合に登場しますが、ベースラインには明確な定義がないため、Robynでは「制御不可能な変数」と定義します。すべてのマーケティング関連変数（有料、オーガニック、価格、プロモーションなど）は制御可能なものと見なされます。一方、季節的な変数（トレンド、シーズン、休日など）、外部変数（競合、天候など）、および切片はベースラインと見なされます。

2. **実際のレスポンス vs. 予測されたレスポンス:** このチャートは、実際のレスポンス変数（例: 収益）とモデルからの予測値を示します。フィットの良さは視覚的に確認できます。この例では、R2は非常に高く（0.9に近い）、実際の値と予測値が視覚的に一致しています。さらに、このプロットは「一致しないイベント」の解釈にも役立ちます。例として、2018年半ばのピークがモデルでまったく捉えられていない場合、そのピークがモデルに組み込まれていない特別なイベントがあったかもしれません。

3. **支出シェア vs. 効果シェア:** このプロットは、モデリング期間全体における有料メディア変数の効果シェアと支出シェアの比較を示しています。これは、目的関数である[DECOMP.RSSD](#objective-function)の視覚化です。さらに、各メディア変数の総投資収益率（ROAS）もプロットされています。なお、このプロットでは、効果の割合はメディア変数のみが対象であり、ウォーターフォール図のようにすべての変数を含むわけではありません。

4. **クラスター内のブートストラップ信頼区間:** Robynはブートストラップを使用して、ROASやCPAの不確実性を計算します。すべてのパレート最適モデル候補が得られた後、K-meansクラスタリングを適用して、類似のハイパーパラメータを持つモデルのクラスターを見つけます。多目的最適化（MOO）の文脈では、これらのクラスターは異なる局所最適におけるサブポピュレーションと見なされます。次に、ROASやCPAの効率指標をブートストラップして、分布と95%信頼区間を取得します。

5. **広告効果の減衰率:** このチャートは、各メディア変数（有料およびオーガニック）のキャリーオーバー効果を表しています。Geometric広告効果の場合、棒グラフは固定減衰率を示します。値が大きいほど、将来に向けてキャリーオーバー効果が強いことを意味します。ワイブル広告効果の場合、各サブチャートは各メディア変数の時間変動する減衰率を示し、遅延効果を含む場合もあります。一般的な広告効果の仮説では、オフラインチャネルはキャリーオーバー効果が強いとされています。

6. **即時効果 vs. キャリーオーバー効果:** Robynは、メディアの貢献を即時効果とキャリーオーバー効果に分割します。即時効果は、特定の期間の直接的なメディア支出の影響を示し、キャリーオーバー効果は過去の支出が漏れ出して（広告効果とも呼ばれる）特定の期間に影響を与える効果です。概念的には、キャリーオーバー効果は、「広告の想起」や「キャンペーン認知度」といった上位ファネルや中位ファネルのブランドエクイティメトリクスの影響として理解できます。なお、メディアの貢献を即時効果とキャリーオーバー効果に分割する際、「短期効果」と「長期効果」という用語は使用しないようにしています。理由として、メディアの直接的な反応への影響は説明できても、ベースラインとの相互作用については何も語られていないためです。この例では、`ooh_S`と`tv_S`のように、キャリーオーバー効果が高いにもかかわらず広告効果が低いチャネルが存在することもあります。その理由は、各メディアの異なる飽和曲線にあり（後述）、これもキャリーオーバーの分解に影響を与えています。

7. **飽和曲線:** 飽和曲線は、レスポンス曲線や収穫逓減としても知られています。Robynは、各メディア変数に対して1つの飽和曲線（ヒル関数のセット）を計算します。灰色の領域は、上記のポイント6で説明したように、履歴のキャリーオーバーを示しています。灰色の領域の終わりがY軸に投影されるとキャリーオーバー効果が示され、点（平均支出）がY軸に投影されると総効果が示されます。これら2つの違いが即時効果です。これらの曲線を理解するには、ビジネスの文脈を使用してください。例えば、オーバースペンドしているメディア変数では、曲線の平坦な部分にドットがあることが予想され、**限界ROAS**（mROAS）や予算配分に最も重要な指標を示します。詳細については、["The convergence of marginal ROAS in the budget allocation in Robyn"](https://medium.com/@gufengzhou/the-convergence-of-marginal-roas-in-the-budget-allocation-in-robyn-5d407aebf021)をご参照ください。`robyn_response()` 関数を使用してこれらのレスポンス曲線を再作成することもできます。詳細は[デモ](https://github.com/facebookexperimental/Robyn/blob/main/demo/demo.R#L518)をご覧ください。

8. **フィット値 vs. 残差値:** このチャートは、フィット値と残差値の関係を示しています。良好なフィットモデルの場合、このプロットはX軸の周りに均等に散らばった点が表示され、ほぼ水平な傾向線が予想されます。反対に、明確なパターン（漏斗型、波形、グループ化された外れ値）が見える場合は、モデルに欠けている変数があることを示している可能性があります。

---
## 予算配分

Robynの予算割り当てツールには2つのシナリオがあります。
- **最大レスポンス**: 総予算とメディアレベルの制約が与えられた場合、レスポンスを最大化する最適なクロスメディア予算割り当てを計算します。例えば、「予算Xがある場合、最適なメディア配分は何か？」
- **ターゲット効率（ROASまたはCPA）**: ターゲットROASまたはCPAとメディアレベルの制約が与えられた場合、レスポンスを最大化する最適なクロスメディア予算割り当てと総予算を計算します。例えば、「ROAS Xを達成するには、最適なメディア配分と必要な予算はどれくらいか？」

Robynは最適化パッケージ「nloptr」を使用して、境界条件と等式制約を持つ勾配ベースの非線形最適化を実行します。グローバル最適化には拡張ラグランジアン（AUGLAG）が使用され、ローカル最適化には逐次最小二乗二次計画法（SLSQP）が使用されます。アルゴリズムの詳細については、[nloptrのドキュメント](https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#slsqp)をご覧ください。

以下は予算割り当ての一例です:

![budget allocator chart](https://facebookexperimental.github.io/Robyn/img/optimizer_new.png)

予算配分Onepagerの解釈については、以下の詳細記事をご参照ください:
- **"The convergence of marginal ROAS in the budget allocation in Robyn"**: [こちら](https://medium.com/@gufengzhou/the-convergence-of-marginal-roas-in-the-budget-allocation-in-robyn-5d407aebf021)
- **"Hitting ROAS target using Robyn’s budget allocator"**: [こちら](https://medium.com/@gufengzhou/hitting-roas-target-using-robyns-budget-allocator-274ace3add4f)

---
## モデルリフレッシュ

従来、MMMのモデルリフレッシュサイクルは半年に一度、またはそれ以上の期間で行われるのが一般的でした。この時間の遅延は、MMMのインサイトがアクションにつながりにくくなる原因となります。Robynのモデルリフレッシュ機能はこの課題を解決し、データが許す限り頻繁にモデルをリフレッシュし、レポートを提供できるようにします。これにより、MMMがレポーティングやBIツールにフィードするための、アクション可能かつタイムリーな意思決定のための継続的なレポートツールとなることが可能になります。

概念的には、`robyn_refresh()` 関数は、選択された初期モデルを基に構築され、新しいデータ/総データの比率に比例した狭い範囲でハイパーパラメータを更新し、目的関数の組み合わせに基づいて最適なモデルを選びます。モデルリフレッシュには、いくつかの一般的な期待があります。短期間の新しいデータでリフレッシュする場合、次のことが期待されます:

- リフレッシュされたモデルは、初期モデルと比較して安定したベースラインを持つこと
- リフレッシュされたモデルは、新しい期間のメディア支出の変化を反映すること

Robynは、これを達成するために修正された目的関数を使用しています。具体的には、NRMSEはリフレッシュ時には新しい期間のみを考慮します。リフレッシュの主な目的は新しい期間をよりよく説明することだからです。DECOMP.RSSDは、効果シェアをリフレッシュの支出シェアに近づけるように修正され、新旧ベースラインの類似性も考慮します。

以下の例は、2017年および2018年の大部分をカバーする初期ウィンドウに基づいた5つの異なる期間のモデルリフレッシュメカニズムを示しています。

![pareto chart 2](https://facebookexperimental.github.io/Robyn/img/refresh-window.png)

2つ目のリフレッシュチャートは、初期モデルとさまざまなリフレッシュモデルにわたるモデルの分解を示しています。

![pareto chart 2](https://facebookexperimental.github.io/Robyn/img/refresh-reporting.png)

**この機能はまだ十分にテストされていない**ため、不安定なリフレッシュ結果を提供する可能性があります。
